# newdoc id = 00842
# newpar id = 00842-p1
# par_text = Комбинаторное программирование
# sent_id = 00842-p1-s1
# text = Комбинаторное программирование
1	Комбинаторное	_	_	_	_	_	_	_	_
2	программирование	_	_	_	_	_	_	_	_

# newpar id = 00842-p2
# par_text = Комбинаторное программирование (function-level programming) — парадигма программирования, использующая принципы комбинáторной логики, то есть не требующая явного упоминания аргументов определяемой функции (программы) и использующая вместо переменных комбинаторы и композиции. Является особой разновидностью функционального программирования, но, в отличие от основного его направления, комбинаторное программирование не использует λ-абстракцию).
# sent_id = 00842-p2-s1
# text = Комбинаторное программирование (function-level programming) - парадигма программирования, использующая принципы комбинáторной логики, то есть не требующая явного упоминания аргументов определяемой функции (программы) и использующая вместо переменных комбинаторы и композиции.
1	Комбинаторное	_	_	_	_	_	_	_	_
2	программирование	_	_	_	_	_	_	_	_
3	(	_	_	_	_	_	_	_	SpaceAfter=No
4	function-level	_	_	_	_	_	_	_	_
5	programming	_	_	_	_	_	_	_	SpaceAfter=No
6	)	_	_	_	_	_	_	_	_
7	-	_	_	_	_	_	_	_	_
8	парадигма	_	_	_	_	_	_	_	_
9	программирования	_	_	_	_	_	_	_	SpaceAfter=No
10	,	_	_	_	_	_	_	_	_
11	использующая	_	_	_	_	_	_	_	_
12	принципы	_	_	_	_	_	_	_	_
12.1	_	_	_	_	_	_	_	_	EntityUnk=комбинáторной
13	логики	_	_	_	_	_	_	_	SpaceAfter=No
14	,	_	_	_	_	_	_	_	_
15	то	_	_	_	_	_	_	_	_
16	есть	_	_	_	_	_	_	_	_
17	не	_	_	_	_	_	_	_	_
18	требующая	_	_	_	_	_	_	_	_
19	явного	_	_	_	_	_	_	_	_
20	упоминания	_	_	_	_	_	_	_	_
21	аргументов	_	_	_	_	_	_	_	_
22	определяемой	_	_	_	_	_	_	_	_
23	функции	_	_	_	_	_	_	_	_
24	(	_	_	_	_	_	_	_	SpaceAfter=No
25	программы	_	_	_	_	_	_	_	SpaceAfter=No
26	)	_	_	_	_	_	_	_	_
27	и	_	_	_	_	_	_	_	_
28	использующая	_	_	_	_	_	_	_	_
29	вместо	_	_	_	_	_	_	_	_
30	переменных	_	_	_	_	_	_	_	_
31	комбинаторы	_	_	_	_	_	_	_	_
32	и	_	_	_	_	_	_	_	_
33	композиции	_	_	_	_	_	_	_	SpaceAfter=No
34	.	_	_	_	_	_	_	_	_

# sent_id = 00842-p2-s2
# text = Является особой разновидностью функционального программирования, но, в отличие от основного его направления, комбинаторное программирование не использует λ-абстракцию).
1	Является	_	_	_	_	_	_	_	_
2	особой	_	_	_	_	_	_	_	_
3	разновидностью	_	_	_	_	_	_	_	_
4	функционального	_	_	_	_	_	_	_	_
5	программирования	_	_	_	_	_	_	_	SpaceAfter=No
6	,	_	_	_	_	_	_	_	_
7	но	_	_	_	_	_	_	_	SpaceAfter=No
8	,	_	_	_	_	_	_	_	_
9	в	_	_	_	_	_	_	_	_
10	отличие	_	_	_	_	_	_	_	_
11	от	_	_	_	_	_	_	_	_
12	основного	_	_	_	_	_	_	_	_
13	его	_	_	_	_	_	_	_	_
14	направления	_	_	_	_	_	_	_	SpaceAfter=No
15	,	_	_	_	_	_	_	_	_
16	комбинаторное	_	_	_	_	_	_	_	_
17	программирование	_	_	_	_	_	_	_	_
18	не	_	_	_	_	_	_	_	_
19	использует	_	_	_	_	_	_	_	_
19.1	_	_	_	_	_	_	_	_	EntityUnk=λ-абстракцию).

# newpar id = 00842-p3
# par_text = Концептуализировал и популяризовал парадигму Джон Бэкус в тьюринговской лекции 1977 года «Можно ли освободить программирование от стиля фон Неймана», в которой представил язык . В конце 1980-х Бэкус с коллегами из Алмаденского исследовательского центра IBM в развитие идей FP и конкатенативной парадигмы разработали язык . При этом элементы конткатенативного программирования проявляются уже в APL, а в более поздних его разновидностях — языках J и K — заимствованы многие идеи FP, и оформлены в концепцию бесточечного стиля, которая применима не только для функционального программирования в строгом смысле (в частности, элементы такого стиля имеют место в оболочках UNIX при применении конвейеров для перенаправления ввода-вывода).
# sent_id = 00842-p3-s1
# text = Концептуализировал и популяризовал парадигму Джон Бэкус в тьюринговской лекции 1977 года ``Можно ли освободить программирование от стиля фон Неймана'', в которой представил язык.
1	Концептуализировал	_	_	_	_	_	_	_	_
2	и	_	_	_	_	_	_	_	_
3	популяризовал	_	_	_	_	_	_	_	_
4	парадигму	_	_	_	_	_	_	_	_
5	Джон	_	_	_	_	_	_	_	_
6	Бэкус	_	_	_	_	_	_	_	_
7	в	_	_	_	_	_	_	_	_
8	тьюринговской	_	_	_	_	_	_	_	_
9	лекции	_	_	_	_	_	_	_	_
10	1977	_	_	_	_	_	_	_	_
11	года	_	_	_	_	_	_	_	_
12	``	_	_	_	_	_	_	_	SpaceAfter=No
13	Можно	_	_	_	_	_	_	_	_
14	ли	_	_	_	_	_	_	_	_
15	освободить	_	_	_	_	_	_	_	_
16	программирование	_	_	_	_	_	_	_	_
17	от	_	_	_	_	_	_	_	_
18	стиля	_	_	_	_	_	_	_	_
19	фон	_	_	_	_	_	_	_	_
20	Неймана	_	_	_	_	_	_	_	SpaceAfter=No
21	''	_	_	_	_	_	_	_	SpaceAfter=No
22	,	_	_	_	_	_	_	_	_
23	в	_	_	_	_	_	_	_	_
24	которой	_	_	_	_	_	_	_	_
25	представил	_	_	_	_	_	_	_	_
26	язык	_	_	_	_	_	_	_	SpaceAfter=No
27	.	_	_	_	_	_	_	_	_

# sent_id = 00842-p3-s2
# text = В конце 1980-х Бэкус с коллегами из Алмаденского исследовательского центра IBM в развитие идей FP и конкатенативной парадигмы разработали язык.
1	В	_	_	_	_	_	_	_	_
2	конце	_	_	_	_	_	_	_	_
3	1980-х	_	_	_	_	_	_	_	_
4	Бэкус	_	_	_	_	_	_	_	_
5	с	_	_	_	_	_	_	_	_
6	коллегами	_	_	_	_	_	_	_	_
7	из	_	_	_	_	_	_	_	_
8	Алмаденского	_	_	_	_	_	_	_	_
9	исследовательского	_	_	_	_	_	_	_	_
10	центра	_	_	_	_	_	_	_	_
11	IBM	_	_	_	_	_	_	_	_
12	в	_	_	_	_	_	_	_	_
13	развитие	_	_	_	_	_	_	_	_
14	идей	_	_	_	_	_	_	_	_
15	FP	_	_	_	_	_	_	_	_
16	и	_	_	_	_	_	_	_	_
17	конкатенативной	_	_	_	_	_	_	_	_
18	парадигмы	_	_	_	_	_	_	_	_
19	разработали	_	_	_	_	_	_	_	_
20	язык	_	_	_	_	_	_	_	SpaceAfter=No
21	.	_	_	_	_	_	_	_	_

# sent_id = 00842-p3-s3
# text = При этом элементы конткатенативного программирования проявляются уже в APL, а в более поздних его разновидностях - языках J и K - заимствованы многие идеи FP, и оформлены в концепцию бесточечного стиля, которая применима не только для функционального программирования в строгом смысле (в частности, элементы такого стиля имеют место в оболочках UNIX при применении конвейеров для перенаправления ввода-вывода).
1	При	_	_	_	_	_	_	_	_
2	этом	_	_	_	_	_	_	_	_
3	элементы	_	_	_	_	_	_	_	_
4	конткатенативного	_	_	_	_	_	_	_	_
5	программирования	_	_	_	_	_	_	_	_
6	проявляются	_	_	_	_	_	_	_	_
7	уже	_	_	_	_	_	_	_	_
8	в	_	_	_	_	_	_	_	_
9	APL	_	_	_	_	_	_	_	SpaceAfter=No
10	,	_	_	_	_	_	_	_	_
11	а	_	_	_	_	_	_	_	_
12	в	_	_	_	_	_	_	_	_
13	более	_	_	_	_	_	_	_	_
14	поздних	_	_	_	_	_	_	_	_
15	его	_	_	_	_	_	_	_	_
16	разновидностях	_	_	_	_	_	_	_	_
17	-	_	_	_	_	_	_	_	_
18	языках	_	_	_	_	_	_	_	_
19	J	_	_	_	_	_	_	_	_
20	и	_	_	_	_	_	_	_	_
21	K	_	_	_	_	_	_	_	_
22	-	_	_	_	_	_	_	_	_
23	заимствованы	_	_	_	_	_	_	_	_
24	многие	_	_	_	_	_	_	_	_
25	идеи	_	_	_	_	_	_	_	_
26	FP	_	_	_	_	_	_	_	SpaceAfter=No
27	,	_	_	_	_	_	_	_	_
28	и	_	_	_	_	_	_	_	_
29	оформлены	_	_	_	_	_	_	_	_
30	в	_	_	_	_	_	_	_	_
31	концепцию	_	_	_	_	_	_	_	_
32	бесточечного	_	_	_	_	_	_	_	_
33	стиля	_	_	_	_	_	_	_	SpaceAfter=No
34	,	_	_	_	_	_	_	_	_
35	которая	_	_	_	_	_	_	_	_
36	применима	_	_	_	_	_	_	_	_
37	не	_	_	_	_	_	_	_	_
38	только	_	_	_	_	_	_	_	_
39	для	_	_	_	_	_	_	_	_
40	функционального	_	_	_	_	_	_	_	_
41	программирования	_	_	_	_	_	_	_	_
42	в	_	_	_	_	_	_	_	_
43	строгом	_	_	_	_	_	_	_	_
44	смысле	_	_	_	_	_	_	_	_
45	(	_	_	_	_	_	_	_	SpaceAfter=No
46	в	_	_	_	_	_	_	_	_
47	частности	_	_	_	_	_	_	_	SpaceAfter=No
48	,	_	_	_	_	_	_	_	_
49	элементы	_	_	_	_	_	_	_	_
50	такого	_	_	_	_	_	_	_	_
51	стиля	_	_	_	_	_	_	_	_
52	имеют	_	_	_	_	_	_	_	_
53	место	_	_	_	_	_	_	_	_
54	в	_	_	_	_	_	_	_	_
55	оболочках	_	_	_	_	_	_	_	_
56	UNIX	_	_	_	_	_	_	_	_
57	при	_	_	_	_	_	_	_	_
58	применении	_	_	_	_	_	_	_	_
59	конвейеров	_	_	_	_	_	_	_	_
60	для	_	_	_	_	_	_	_	_
61	перенаправления	_	_	_	_	_	_	_	_
62	ввода-вывода	_	_	_	_	_	_	_	SpaceAfter=No
63	)	_	_	_	_	_	_	_	SpaceAfter=No
64	.	_	_	_	_	_	_	_	_

